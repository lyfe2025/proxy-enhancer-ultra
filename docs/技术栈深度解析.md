# æŠ€æœ¯æ ˆæ·±åº¦è§£æä¸è·¯ç”±åŸç†

## ğŸ“‹ ç›®å½•
1. [æŠ€æœ¯é€‰å‹åˆ†æ](#æŠ€æœ¯é€‰å‹åˆ†æ)
2. [è·¯ç”±ç³»ç»Ÿæ·±åº¦è§£æ](#è·¯ç”±ç³»ç»Ÿæ·±åº¦è§£æ)
3. [å‰åç«¯æ¶æ„å¯¹æ¯”](#å‰åç«¯æ¶æ„å¯¹æ¯”)
4. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
5. [å®‰å…¨æœºåˆ¶è¯¦è§£](#å®‰å…¨æœºåˆ¶è¯¦è§£)

## ğŸ” æŠ€æœ¯é€‰å‹åˆ†æ

### ä¸ºä»€ä¹ˆé€‰æ‹© Goï¼Ÿ

#### 1. **é«˜æ€§èƒ½ç‰¹æ€§**
```go
// Go çš„å¹¶å‘æ¨¡å‹ç¤ºä¾‹
func handleProxyRequest(w http.ResponseWriter, r *http.Request) {
    // æ¯ä¸ªè¯·æ±‚éƒ½åœ¨ç‹¬ç«‹çš„ goroutine ä¸­å¤„ç†
    go func() {
        // å¼‚æ­¥å¤„ç†ä»£ç†é€»è¾‘
        processProxyRequest(r)
    }()
    
    // ç«‹å³è¿”å›å“åº”
    w.WriteHeader(http.StatusOK)
}
```

**ä¼˜åŠ¿**ï¼š
- **Goroutine**ï¼šè½»é‡çº§çº¿ç¨‹ï¼Œå¯åŒæ—¶å¤„ç†æ•°ä¸‡ä¸ªå¹¶å‘è¿æ¥
- **å†…å­˜ç®¡ç†**ï¼šè‡ªåŠ¨åƒåœ¾å›æ”¶ï¼Œå‡å°‘å†…å­˜æ³„æ¼é£é™©
- **ç¼–è¯‘å‹è¯­è¨€**ï¼šç›´æ¥ç¼–è¯‘ä¸ºæœºå™¨ç ï¼Œæ‰§è¡Œæ•ˆç‡é«˜

#### 2. **æ ‡å‡†åº“æ”¯æŒ**
```go
// ä½¿ç”¨æ ‡å‡†åº“å®ç°åå‘ä»£ç†
import (
    "net/http"
    "net/http/httputil"
    "net/url"
)

func createReverseProxy(targetURL string) *httputil.ReverseProxy {
    target, _ := url.Parse(targetURL)
    proxy := httputil.NewSingleHostReverseProxy(target)
    
    // è‡ªå®šä¹‰å“åº”ä¿®æ”¹
    proxy.ModifyResponse = func(resp *http.Response) error {
        // åœ¨è¿™é‡Œæ³¨å…¥å¼¹çª—æˆ–ä¿®æ”¹å†…å®¹
        return injectCustomContent(resp)
    }
    
    return proxy
}
```

**ä¼˜åŠ¿**ï¼š
- **net/http**ï¼šæˆç†Ÿçš„ HTTP æœåŠ¡å™¨å®ç°
- **httputil.ReverseProxy**ï¼šä¸“é—¨çš„åå‘ä»£ç†å·¥å…·
- **html/template**ï¼šå®‰å…¨çš„æ¨¡æ¿å¼•æ“

### ä¸ºä»€ä¹ˆé€‰æ‹© Vue 3 + TypeScriptï¼Ÿ

#### 1. **ç»„åˆå¼ API**
```typescript
// Vue 3 ç»„åˆå¼ API ç¤ºä¾‹
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useProxyStore } from '@/store/proxy'

// å“åº”å¼çŠ¶æ€
const proxyList = ref<ProxyConfig[]>([])
const loading = ref(false)

// è®¡ç®—å±æ€§
const activeProxies = computed(() => 
  proxyList.value.filter(p => p.isActive)
)

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  await loadProxyConfigs()
})

// ä¸šåŠ¡é€»è¾‘
const loadProxyConfigs = async () => {
  loading.value = true
  try {
    const store = useProxyStore()
    proxyList.value = await store.fetchConfigs()
  } finally {
    loading.value = false
  }
}
</script>
```

**ä¼˜åŠ¿**ï¼š
- **TypeScript**ï¼šç±»å‹å®‰å…¨ï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯
- **ç»„åˆå¼ API**ï¼šæ›´å¥½çš„é€»è¾‘å¤ç”¨å’Œæµ‹è¯•
- **å“åº”å¼ç³»ç»Ÿ**ï¼šè‡ªåŠ¨ä¾èµ–è¿½è¸ªå’Œæ›´æ–°

#### 2. **ç”Ÿæ€ç³»ç»Ÿ**
```typescript
// Element Plus ç»„ä»¶ä½¿ç”¨
<template>
  <el-table :data="proxyList" v-loading="loading">
    <el-table-column prop="name" label="ä»£ç†åç§°" />
    <el-table-column prop="targetUrl" label="ç›®æ ‡ç½‘ç«™" />
    <el-table-column prop="isActive" label="çŠ¶æ€">
      <template #default="{ row }">
        <el-tag :type="row.isActive ? 'success' : 'danger'">
          {{ row.isActive ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢' }}
        </el-tag>
      </template>
    </el-table-column>
    <el-table-column label="æ“ä½œ">
      <template #default="{ row }">
        <el-button @click="editProxy(row)">ç¼–è¾‘</el-button>
        <el-button @click="toggleProxy(row)" 
                   :type="row.isActive ? 'warning' : 'success'">
          {{ row.isActive ? 'åœæ­¢' : 'å¯åŠ¨' }}
        </el-button>
      </template>
    </el-table-column>
  </el-table>
</template>
```

## ğŸ›£ï¸ è·¯ç”±ç³»ç»Ÿæ·±åº¦è§£æ

### è·¯ç”±åŒ¹é…åŸç†

#### 1. **gorilla/mux è·¯ç”±åŒ¹é…æœºåˆ¶**

```go
// è·¯ç”±æ³¨å†Œé¡ºåºçš„é‡è¦æ€§
func setupRouter() *mux.Router {
    router := mux.NewRouter()
    
    // 1. ç²¾ç¡®åŒ¹é…è·¯ç”±ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
    router.HandleFunc("/admin", adminHandler.Index).Methods("GET")
    router.HandleFunc("/api/health", healthHandler.Check).Methods("GET")
    
    // 2. å‰ç¼€åŒ¹é…è·¯ç”±
    adminRouter := router.PathPrefix("/admin").Subrouter()
    adminRouter.HandleFunc("/proxy", proxyHandler.Index).Methods("GET")
    adminRouter.HandleFunc("/rules", rulesHandler.Index).Methods("GET")
    
    apiRouter := router.PathPrefix("/api").Subrouter()
    apiRouter.HandleFunc("/auth/login", authHandler.Login).Methods("POST")
    apiRouter.HandleFunc("/proxy/configs", proxyHandler.List).Methods("GET")
    
    // 3. é€šé…ç¬¦è·¯ç”±ï¼ˆå¿…é¡»æ”¾åœ¨æœ€åï¼‰
    router.PathPrefix("/").HandlerFunc(proxyHandler.ServeProxy)
    
    return router
}
```

**è·¯ç”±åŒ¹é…é¡ºåº**ï¼š
1. **ç²¾ç¡®åŒ¹é…**ï¼š`/admin` â†’ `adminHandler.Index`
2. **å‰ç¼€åŒ¹é…**ï¼š`/admin/proxy` â†’ `proxyHandler.Index`
3. **é€šé…ç¬¦åŒ¹é…**ï¼š`/anything` â†’ `proxyHandler.ServeProxy`

#### 2. **è·¯ç”±å‚æ•°æå–**

```go
// åŠ¨æ€è·¯ç”±å‚æ•°
func setupDynamicRoutes(router *mux.Router) {
    // è·¯å¾„å‚æ•°
    router.HandleFunc("/api/proxy/{id}", proxyHandler.GetByID).Methods("GET")
    router.HandleFunc("/api/rules/{ruleId}", rulesHandler.GetByID).Methods("GET")
    
    // æŸ¥è¯¢å‚æ•°å¤„ç†
    router.HandleFunc("/api/proxy", proxyHandler.List).Methods("GET")
}

// å¤„ç†å™¨ä¸­è·å–å‚æ•°
func (h *ProxyHandler) GetByID(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"] // ä»è·¯å¾„ä¸­æå– ID
    
    query := r.URL.Query()
    page := query.Get("page")     // ä»æŸ¥è¯¢å­—ç¬¦ä¸²è·å–
    limit := query.Get("limit")
    
    // ä¸šåŠ¡é€»è¾‘...
}
```

#### 3. **ä¸­é—´ä»¶é“¾å¼è°ƒç”¨**

```go
// ä¸­é—´ä»¶æ³¨å†Œå’Œé“¾å¼è°ƒç”¨
func setupMiddleware(router *mux.Router) {
    // å…¨å±€ä¸­é—´ä»¶
    router.Use(
        middleware.Logging,      // æ—¥å¿—è®°å½•
        middleware.CORS,         // è·¨åŸŸå¤„ç†
        middleware.Recovery,     // é”™è¯¯æ¢å¤
    )
    
    // API è·¯ç”±ä¸­é—´ä»¶
    apiRouter := router.PathPrefix("/api").Subrouter()
    apiRouter.Use(
        middleware.RateLimit,    // é€Ÿç‡é™åˆ¶
        middleware.Compression,  // å“åº”å‹ç¼©
    )
    
    // å—ä¿æŠ¤è·¯ç”±ä¸­é—´ä»¶
    protectedRouter := apiRouter.PathPrefix("").Subrouter()
    protectedRouter.Use(
        middleware.JWTAuth,      // JWT è®¤è¯
        middleware.Authorization, // æƒé™æ£€æŸ¥
    )
}
```

### å‰ç«¯è·¯ç”±ç³»ç»Ÿ

#### 1. **Vue Router 4 é…ç½®**

```typescript
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/store/auth'

const routes = [
  {
    path: '/admin',
    component: () => import('@/views/layout/AdminLayout.vue'),
    meta: { 
      requiresAuth: true,
      title: 'ç®¡ç†åå°'
    },
    children: [
      {
        path: 'proxy',
        name: 'ProxyManagement',
        component: () => import('@/views/proxy/ProxyManagement.vue'),
        meta: { 
          title: 'ä»£ç†ç®¡ç†',
          permission: 'proxy.manage'
        }
      },
      {
        path: 'rules',
        name: 'RulesManagement',
        component: () => import('@/views/rules/RulesManagement.vue'),
        meta: { 
          title: 'è§„åˆ™é…ç½®',
          permission: 'rules.manage'
        }
      }
    ]
  },
  {
    path: '/admin/login',
    name: 'Login',
    component: () => import('@/views/auth/Login.vue'),
    meta: { 
      requiresAuth: false,
      title: 'ç”¨æˆ·ç™»å½•'
    }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// è·¯ç”±å®ˆå«
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // è®¾ç½®é¡µé¢æ ‡é¢˜
  if (to.meta.title) {
    document.title = `${to.meta.title} - Proxy Enhancer Ultra`
  }
  
  // æ£€æŸ¥è®¤è¯çŠ¶æ€
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next('/admin/login')
    return
  }
  
  // æ£€æŸ¥æƒé™
  if (to.meta.permission && !authStore.hasPermission(to.meta.permission)) {
    next('/admin/403')
    return
  }
  
  next()
})

export default router
```

#### 2. **åŠ¨æ€è·¯ç”±ç”Ÿæˆ**

```typescript
// æ ¹æ®ç”¨æˆ·æƒé™åŠ¨æ€ç”Ÿæˆè·¯ç”±
export function generateDynamicRoutes(userPermissions: string[]) {
  const dynamicRoutes = []
  
  // æ ¹æ®æƒé™è¿‡æ»¤è·¯ç”±
  const filteredRoutes = routes.filter(route => {
    if (!route.meta?.permission) return true
    return userPermissions.includes(route.meta.permission)
  })
  
  // åŠ¨æ€æ·»åŠ è·¯ç”±
  filteredRoutes.forEach(route => {
    router.addRoute(route)
  })
  
  return dynamicRoutes
}
```

## ğŸ”„ å‰åç«¯æ¶æ„å¯¹æ¯”

### æ¶æ„æ¨¡å¼å¯¹æ¯”

#### 1. **ä¼ ç»Ÿåˆ†ç¦»æ¶æ„ vs ç»Ÿä¸€æ¶æ„**

```
ä¼ ç»Ÿåˆ†ç¦»æ¶æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å‰ç«¯      â”‚    â”‚   åç«¯      â”‚    â”‚   æ•°æ®åº“    â”‚
â”‚   (Vue)     â”‚â—„â”€â”€â–ºâ”‚   (Go)      â”‚â—„â”€â”€â–ºâ”‚ (PostgreSQL)â”‚
â”‚   Port:3000 â”‚    â”‚   Port:8080 â”‚    â”‚   Port:5432 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç»Ÿä¸€æ¶æ„ï¼ˆæœ¬é¡¹ç›®ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Go ç»Ÿä¸€æœåŠ¡                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚  å‰ç«¯é™æ€   â”‚  â”‚  åç«¯API    â”‚              â”‚
â”‚  â”‚   æ–‡ä»¶      â”‚  â”‚   æœåŠ¡      â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚              Port:8080                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚  æ•°æ®åº“     â”‚
                       â”‚ PostgreSQL  â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2. **ä¼˜åŠ¿å¯¹æ¯”**

| æ–¹é¢ | ä¼ ç»Ÿåˆ†ç¦»æ¶æ„ | ç»Ÿä¸€æ¶æ„ |
|------|-------------|----------|
| **éƒ¨ç½²å¤æ‚åº¦** | éœ€è¦éƒ¨ç½²ä¸¤ä¸ªæœåŠ¡ | åªéœ€éƒ¨ç½²ä¸€ä¸ªæœåŠ¡ |
| **è·¨åŸŸé—®é¢˜** | éœ€è¦é…ç½® CORS | æ— è·¨åŸŸé—®é¢˜ |
| **æ€§èƒ½** | ä¸¤æ¬¡ç½‘ç»œè¯·æ±‚ | ä¸€æ¬¡ç½‘ç»œè¯·æ±‚ |
| **ç»´æŠ¤æˆæœ¬** | éœ€è¦ç»´æŠ¤ä¸¤ä¸ªæœåŠ¡ | ç»Ÿä¸€ç»´æŠ¤ |
| **æ‰©å±•æ€§** | å¯ä»¥ç‹¬ç«‹æ‰©å±• | æ•´ä½“æ‰©å±• |

### æ•°æ®æµå¯¹æ¯”

#### 1. **ä¼ ç»Ÿæ¶æ„æ•°æ®æµ**
```
ç”¨æˆ·è¯·æ±‚ â†’ å‰ç«¯è·¯ç”± â†’ API è°ƒç”¨ â†’ åç«¯å¤„ç† â†’ æ•°æ®åº“ â†’ è¿”å›æ•°æ® â†’ å‰ç«¯æ¸²æŸ“
```

#### 2. **ç»Ÿä¸€æ¶æ„æ•°æ®æµ**
```
ç”¨æˆ·è¯·æ±‚ â†’ Go è·¯ç”±åˆ†å‘ â†’ é™æ€æ–‡ä»¶/API å¤„ç† â†’ æ•°æ®åº“ â†’ è¿”å›ç»“æœ
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. **åç«¯æ€§èƒ½ä¼˜åŒ–**

#### è¿æ¥æ± ç®¡ç†
```go
// æ•°æ®åº“è¿æ¥æ± é…ç½®
func initDatabase(config *config.Config) *gorm.DB {
    dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
        config.Database.Host,
        config.Database.Port,
        config.Database.User,
        config.Database.Password,
        config.Database.Name,
        config.Database.SSLMode,
    )
    
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
        // è¿æ¥æ± é…ç½®
        PrepareStmt: true,           // é¢„ç¼–è¯‘è¯­å¥
        SkipDefaultTransaction: true, // è·³è¿‡é»˜è®¤äº‹åŠ¡
    })
    
    if err != nil {
        log.Fatal(err)
    }
    
    sqlDB, err := db.DB()
    if err != nil {
        log.Fatal(err)
    }
    
    // è¿æ¥æ± è®¾ç½®
    sqlDB.SetMaxIdleConns(10)        // æœ€å¤§ç©ºé—²è¿æ¥æ•°
    sqlDB.SetMaxOpenConns(100)       // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    sqlDB.SetConnMaxLifetime(time.Hour) // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
    
    return db
}
```

#### ç¼“å­˜ç­–ç•¥
```go
// Redis ç¼“å­˜å®ç°
type CacheService struct {
    client *redis.Client
}

func (s *CacheService) GetProxyConfigs(key string) ([]ProxyConfig, error) {
    // å…ˆä»ç¼“å­˜è·å–
    cached, err := s.client.Get(context.Background(), key).Result()
    if err == nil {
        var configs []ProxyConfig
        json.Unmarshal([]byte(cached), &configs)
        return configs, nil
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“è·å–
    configs, err := s.proxyRepo.GetAll()
    if err != nil {
        return nil, err
    }
    
    // å†™å…¥ç¼“å­˜
    data, _ := json.Marshal(configs)
    s.client.Set(context.Background(), key, data, time.Hour)
    
    return configs, nil
}
```

### 2. **å‰ç«¯æ€§èƒ½ä¼˜åŒ–**

#### ä»£ç åˆ†å‰²
```typescript
// è·¯ç”±çº§åˆ«çš„ä»£ç åˆ†å‰²
const routes = [
  {
    path: '/admin/proxy',
    component: () => import('@/views/proxy/ProxyManagement.vue'),
    // é¢„åŠ è½½
    meta: { preload: true }
  }
]

// ç»„ä»¶çº§åˆ«çš„ä»£ç åˆ†å‰²
const LazyComponent = defineAsyncComponent(() => 
  import('@/components/HeavyComponent.vue')
)
```

#### çŠ¶æ€ç®¡ç†ä¼˜åŒ–
```typescript
// Pinia çŠ¶æ€æŒä¹…åŒ–
export const useProxyStore = defineStore('proxy', {
  state: () => ({
    configs: [],
    loading: false
  }),
  
  persist: {
    enabled: true,
    strategies: [
      {
        key: 'proxy-store',
        storage: localStorage,
        paths: ['configs'] // åªæŒä¹…åŒ–é…ç½®æ•°æ®
      }
    ]
  }
})
```

## ğŸ”’ å®‰å…¨æœºåˆ¶è¯¦è§£

### 1. **JWT è®¤è¯æœºåˆ¶**

#### Token ç»“æ„
```go
// JWT Claims ç»“æ„
type Claims struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    Role     string `json:"role"`
    jwt.RegisteredClaims
}

// Token ç”Ÿæˆ
func generateToken(user *User) (string, error) {
    claims := Claims{
        UserID:   user.ID,
        Username: user.Username,
        Role:     user.Role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            NotBefore: jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(config.JWT.Secret))
}
```

#### ä¸­é—´ä»¶éªŒè¯
```go
func JWTAuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // è·å– Authorization å¤´
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Authorization header required", http.StatusUnauthorized)
            return
        }
        
        // æå– token
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            http.Error(w, "Invalid token format", http.StatusUnauthorized)
            return
        }
        
        // éªŒè¯ token
        token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
            return []byte(config.JWT.Secret), nil
        })
        
        if err != nil || !token.Valid {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
        claims := token.Claims.(*Claims)
        ctx := context.WithValue(r.Context(), "user", claims)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

### 2. **CORS å®‰å…¨é…ç½®**

```go
// CORS ä¸­é—´ä»¶é…ç½®
func CORSMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // è®¾ç½®å…è®¸çš„æº
        origin := r.Header.Get("Origin")
        if origin != "" {
            w.Header().Set("Access-Control-Allow-Origin", origin)
        }
        
        // è®¾ç½®å…è®¸çš„æ–¹æ³•
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        
        // è®¾ç½®å…è®¸çš„å¤´éƒ¨
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
        
        // è®¾ç½®å…è®¸æºå¸¦å‡­è¯
        w.Header().Set("Access-Control-Allow-Credentials", "true")
        
        // é¢„æ£€è¯·æ±‚å¤„ç†
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}
```

### 3. **è¾“å…¥éªŒè¯å’Œæ¸…ç†**

```go
// è¯·æ±‚éªŒè¯
type CreateProxyRequest struct {
    Name        string `json:"name" validate:"required,min=1,max=100"`
    TargetURL   string `json:"target_url" validate:"required,url"`
    ProxyDomain string `json:"proxy_domain" validate:"required,min=1,max=255"`
}

func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    var req CreateProxyRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    // éªŒè¯è¯·æ±‚æ•°æ®
    if err := validate.Struct(req); err != nil {
        http.Error(w, "Validation failed", http.StatusBadRequest)
        return
    }
    
    // æ¸…ç†è¾“å…¥æ•°æ®
    req.Name = strings.TrimSpace(req.Name)
    req.TargetURL = strings.TrimSpace(req.TargetURL)
    req.ProxyDomain = strings.TrimSpace(req.ProxyDomain)
    
    // ä¸šåŠ¡é€»è¾‘å¤„ç†...
}
```

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### 1. **ç»“æ„åŒ–æ—¥å¿—**

```go
// ä½¿ç”¨ logrus è¿›è¡Œç»“æ„åŒ–æ—¥å¿—è®°å½•
import "github.com/sirupsen/logrus"

func setupLogging(config *config.Config) {
    // è®¾ç½®æ—¥å¿—çº§åˆ«
    level, err := logrus.ParseLevel(config.Logging.Level)
    if err != nil {
        level = logrus.InfoLevel
    }
    logrus.SetLevel(level)
    
    // è®¾ç½®æ—¥å¿—æ ¼å¼
    if config.Logging.Format == "json" {
        logrus.SetFormatter(&logrus.JSONFormatter{
            TimestampFormat: time.RFC3339,
        })
    }
    
    // è®¾ç½®è¾“å‡º
    if config.Logging.Output == "file" {
        file, err := os.OpenFile(config.Logging.FilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err == nil {
            logrus.SetOutput(file)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    logrus.WithFields(logrus.Fields{
        "method":     r.Method,
        "path":       r.URL.Path,
        "user_agent": r.UserAgent(),
        "ip":         r.RemoteAddr,
    }).Info("Creating new proxy configuration")
    
    // ä¸šåŠ¡é€»è¾‘...
}
```

### 2. **æ€§èƒ½ç›‘æ§**

```go
// è¯·æ±‚è€—æ—¶ç›‘æ§
func TimingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // åŒ…è£… ResponseWriter ä»¥æ•è·çŠ¶æ€ç 
        wrapped := &responseWriter{ResponseWriter: w}
        
        next.ServeHTTP(wrapped, r)
        
        duration := time.Since(start)
        
        logrus.WithFields(logrus.Fields{
            "method":     r.Method,
            "path":       r.URL.Path,
            "status":     wrapped.status,
            "duration":   duration,
            "user_agent": r.UserAgent(),
        }).Info("Request completed")
    })
}

type responseWriter struct {
    http.ResponseWriter
    status int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.status = code
    rw.ResponseWriter.WriteHeader(code)
}
```

## ğŸš€ æ€»ç»“

é€šè¿‡æ·±å…¥åˆ†æ Proxy Enhancer Ultra çš„æŠ€æœ¯æ ˆå’Œæ¶æ„è®¾è®¡ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼š

### æŠ€æœ¯é€‰å‹çš„åˆç†æ€§
1. **Go è¯­è¨€**ï¼šé«˜æ€§èƒ½ã€å¹¶å‘å¤„ç†èƒ½åŠ›å¼ºï¼Œé€‚åˆä»£ç†æœåŠ¡
2. **Vue 3 + TypeScript**ï¼šç°ä»£åŒ–å‰ç«¯æŠ€æœ¯ï¼Œå¼€å‘æ•ˆç‡é«˜
3. **ç»Ÿä¸€æ¶æ„**ï¼šç®€åŒ–éƒ¨ç½²å’Œç»´æŠ¤ï¼Œå‡å°‘è·¨åŸŸé—®é¢˜

### æ¶æ„è®¾è®¡çš„ä¼˜åŠ¿
1. **æ¨¡å—åŒ–è®¾è®¡**ï¼šæ¸…æ™°çš„èŒè´£åˆ†ç¦»ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **è·¯ç”±ç³»ç»Ÿ**ï¼šçµæ´»çš„è·¯ç”±åŒ¹é…ï¼Œæ”¯æŒå¤æ‚çš„ä¸šåŠ¡éœ€æ±‚
3. **å®‰å…¨æœºåˆ¶**ï¼šå®Œå–„çš„è®¤è¯ã€æˆæƒå’Œè¾“å…¥éªŒè¯

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
1. **è¿æ¥æ± ç®¡ç†**ï¼šæ•°æ®åº“å’Œ HTTP è¿æ¥å¤ç”¨
2. **ç¼“å­˜ç­–ç•¥**ï¼šå‡å°‘é‡å¤è®¡ç®—å’Œæ•°æ®åº“æŸ¥è¯¢
3. **ä»£ç åˆ†å‰²**ï¼šæŒ‰éœ€åŠ è½½ï¼Œå‡å°‘åˆå§‹åŒ…å¤§å°

è¿™ä¸ªé¡¹ç›®å±•ç°äº†ç°ä»£ Web åº”ç”¨çš„æœ€ä½³å®è·µï¼Œæ— è®ºæ˜¯æŠ€æœ¯é€‰å‹ã€æ¶æ„è®¾è®¡è¿˜æ˜¯æ€§èƒ½ä¼˜åŒ–éƒ½å€¼å¾—å­¦ä¹ å’Œå€Ÿé‰´ã€‚

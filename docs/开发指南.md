# Proxy Enhancer Ultra - 开发指南

## 📋 目录
1. [开发环境搭建](#开发环境搭建)
2. [代码规范](#代码规范)
3. [开发流程](#开发流程)
4. [测试指南](#测试指南)
5. [调试技巧](#调试技巧)
6. [常见问题](#常见问题)

## 🚀 开发环境搭建

### 环境要求

#### 1. **Go 环境**
```bash
# 检查 Go 版本
go version

# 要求：Go 1.21 或更高版本
# 下载地址：https://golang.org/dl/
```

#### 2. **Node.js 环境**
```bash
# 检查 Node.js 版本
node --version
npm --version

# 要求：Node.js 18+ 和 npm 8+
# 推荐使用 nvm 管理 Node.js 版本
```

#### 3. **数据库环境**
```bash
# PostgreSQL 12+
# 本地安装 PostgreSQL
brew install postgresql  # macOS
sudo apt-get install postgresql postgresql-contrib  # Ubuntu
```

#### 4. **开发工具**
```bash
# 推荐 IDE
- GoLand / VS Code (Go 开发)
- VS Code / WebStorm (前端开发)
- DBeaver / pgAdmin (数据库管理)
```

### 环境配置步骤

#### 1. **克隆项目**
```bash
git clone <repository-url>
cd proxy-enhancer-ultra

# 检查项目结构
ls -la
```

#### 2. **后端环境配置**
```bash
# 安装 Go 依赖
go mod download

# 复制配置文件
cp config.yaml.example config.yaml

# 编辑配置文件
vim config.yaml
```

**配置文件示例**：
```yaml
# config.yaml
server:
  host: "0.0.0.0"
  port: 8080

database:
  postgres:
    host: "localhost"
    port: 5432
    user: "postgres"
    password: "your-password"
    dbname: "proxy_platform"
    sslmode: "disable"

jwt:
  secret: "your-secret-key-here"
  expires_in: 24h
```

#### 3. **前端环境配置**
```bash
# 进入前端目录
cd web

# 安装依赖
npm install

# 检查依赖安装
npm list --depth=0
```

#### 4. **数据库初始化**
```sql
-- 连接到 PostgreSQL
psql -U postgres -h localhost

-- 创建数据库
CREATE DATABASE proxy_platform;

-- 创建用户（可选）
CREATE USER proxy_user WITH PASSWORD 'proxy_password';
GRANT ALL PRIVILEGES ON DATABASE proxy_platform TO proxy_user;

-- 退出
\q
```

### 开发环境启动

#### 1. **启动后端服务**
```bash
# 在项目根目录
go run cmd/server/main.go

# 或者构建后运行
go build -o bin/server cmd/server/main.go
./bin/server
```

#### 2. **启动前端开发服务器**
```bash
# 在 web 目录
cd web
npm run dev

# 前端将在 http://localhost:5173 启动
```

#### 3. **验证环境**
```bash
# 检查后端服务
curl http://localhost:8080/health

# 检查前端服务
open http://localhost:5173
```

## 📝 代码规范

### Go 代码规范

#### 1. **文件组织**
```go
// 文件结构示例
package proxy

import (
    // 标准库
    "context"
    "net/http"
    
    // 第三方库
    "github.com/gorilla/mux"
    "gorm.io/gorm"
    
    // 内部包
    "proxy-enhancer-ultra/internal/models"
    "proxy-enhancer-ultra/internal/services"
)

// 类型定义
type ProxyHandler struct {
    proxyService *services.ProxyService
    db          *gorm.DB
}

// 构造函数
func NewProxyHandler(proxyService *services.ProxyService, db *gorm.DB) *ProxyHandler {
    return &ProxyHandler{
        proxyService: proxyService,
        db:          db,
    }
}

// 方法实现
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    // 实现逻辑
}
```

#### 2. **命名规范**
```go
// 包名：小写，简短
package proxy

// 类型名：驼峰命名，首字母大写
type ProxyConfig struct {
    ID          string    `json:"id"`
    Name        string    `json:"name"`
    TargetURL   string    `json:"target_url"`
    IsActive    bool      `json:"is_active"`
    CreatedAt   time.Time `json:"created_at"`
}

// 方法名：驼峰命名，首字母大写
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request)
func (h *ProxyHandler) GetProxyByID(w http.ResponseWriter, r *http.Request)

// 变量名：驼峰命名，首字母小写
var proxyConfig ProxyConfig
var isActive bool
```

#### 3. **错误处理**
```go
// 错误处理最佳实践
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    // 1. 解析请求
    var req CreateProxyRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        logrus.WithError(err).Error("Failed to decode request")
        http.Error(w, "Invalid request format", http.StatusBadRequest)
        return
    }
    
    // 2. 验证请求
    if err := h.validateRequest(req); err != nil {
        logrus.WithError(err).Error("Request validation failed")
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // 3. 业务逻辑
    proxy, err := h.proxyService.CreateProxy(r.Context(), req)
    if err != nil {
        logrus.WithError(err).Error("Failed to create proxy")
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    // 4. 返回响应
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(proxy)
}
```

#### 4. **日志规范**
```go
// 使用结构化日志
import "github.com/sirupsen/logrus"

func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    logger := logrus.WithFields(logrus.Fields{
        "method": r.Method,
        "path":   r.URL.Path,
        "ip":     r.RemoteAddr,
    })
    
    logger.Info("Creating new proxy configuration")
    
    // 业务逻辑...
    
    if err != nil {
        logger.WithError(err).Error("Failed to create proxy")
        return
    }
    
    logger.WithField("proxy_id", proxy.ID).Info("Proxy created successfully")
}
```

### 前端代码规范

#### 1. **Vue 组件结构**
```vue
<template>
  <!-- 模板内容 -->
  <div class="proxy-management">
    <el-card>
      <template #header>
        <span>代理管理</span>
      </template>
      
      <el-table :data="proxyList" v-loading="loading">
        <!-- 表格内容 -->
      </el-table>
    </el-card>
  </div>
</template>

<script setup lang="ts">
// 导入
import { ref, onMounted } from 'vue'
import { useProxyStore } from '@/store/proxy'
import type { ProxyConfig } from '@/types'

// 类型定义
interface Props {
  title?: string
}

// Props 和 Emits
const props = withDefaults(defineProps<Props>(), {
  title: '代理管理'
})

// 响应式状态
const proxyList = ref<ProxyConfig[]>([])
const loading = ref(false)

// 计算属性
const activeProxies = computed(() => 
  proxyList.value.filter(p => p.isActive)
)

// 生命周期
onMounted(async () => {
  await loadProxyConfigs()
})

// 方法
const loadProxyConfigs = async () => {
  loading.value = true
  try {
    const store = useProxyStore()
    proxyList.value = await store.fetchConfigs()
  } catch (error) {
    console.error('Failed to load proxy configs:', error)
  } finally {
    loading.value = false
  }
}
</script>

<style scoped>
.proxy-management {
  padding: 20px;
}
</style>
```

#### 2. **TypeScript 类型定义**
```typescript
// types/index.ts
export interface ProxyConfig {
  id: string
  name: string
  targetUrl: string
  proxyDomain: string
  isActive: boolean
  createdAt: string
  updatedAt: string
}

export interface CreateProxyRequest {
  name: string
  targetUrl: string
  proxyDomain: string
}

export interface ApiResponse<T> {
  success: boolean
  data?: T
  message?: string
  error?: string
}

// API 函数类型
export type ApiFunction<T = any, R = any> = (params: T) => Promise<ApiResponse<R>>
```

#### 3. **状态管理规范**
```typescript
// store/proxy.ts
import { defineStore } from 'pinia'
import type { ProxyConfig, CreateProxyRequest } from '@/types'
import { proxyApi } from '@/api/proxy'

export const useProxyStore = defineStore('proxy', {
  state: () => ({
    configs: [] as ProxyConfig[],
    loading: false,
    error: null as string | null,
  }),
  
  getters: {
    activeConfigs: (state) => state.configs.filter(c => c.isActive),
    configById: (state) => (id: string) => state.configs.find(c => c.id === id),
  },
  
  actions: {
    async fetchConfigs() {
      this.loading = true
      this.error = null
      
      try {
        const response = await proxyApi.getConfigs()
        if (response.success && response.data) {
          this.configs = response.data
        }
      } catch (error) {
        this.error = error instanceof Error ? error.message : 'Unknown error'
        throw error
      } finally {
        this.loading = false
      }
    },
    
    async createConfig(request: CreateProxyRequest) {
      this.loading = true
      this.error = null
      
      try {
        const response = await proxyApi.createConfig(request)
        if (response.success && response.data) {
          this.configs.push(response.data)
        }
        return response.data
      } catch (error) {
        this.error = error instanceof Error ? error.message : 'Unknown error'
        throw error
      } finally {
        this.loading = false
      }
    },
  },
})
```

## 🔄 开发流程

### 1. **功能开发流程**

#### 需求分析
```bash
# 1. 理解需求
- 阅读产品需求文档
- 分析技术可行性
- 确定开发范围

# 2. 技术设计
- 设计数据模型
- 设计 API 接口
- 设计前端组件
```

#### 开发实施
```bash
# 1. 后端开发
- 创建数据模型
- 实现业务服务
- 实现 HTTP 处理器
- 添加路由配置

# 2. 前端开发
- 创建 Vue 组件
- 实现状态管理
- 添加路由配置
- 实现 API 调用
```

#### 测试验证
```bash
# 1. 单元测试
go test ./internal/services/...
npm run test:unit

# 2. 集成测试
go test -tags=integration ./...
npm run test:integration

# 3. 端到端测试
npm run test:e2e
```

### 2. **代码提交规范**

#### Git 提交信息格式
```bash
# 提交信息格式
<type>(<scope>): <subject>

# 类型说明
feat:     新功能
fix:      修复 bug
docs:     文档更新
style:    代码格式调整
refactor: 代码重构
test:     测试相关
chore:    构建过程或辅助工具的变动

# 示例
feat(proxy): 添加代理配置管理功能
fix(auth): 修复 JWT 过期时间计算错误
docs(readme): 更新项目启动说明
style(api): 统一 API 响应格式
```

#### 分支管理策略
```bash
# 主分支
main        # 生产环境分支
develop     # 开发环境分支

# 功能分支
feature/proxy-management    # 代理管理功能
feature/rule-engine        # 规则引擎功能
feature/user-management    # 用户管理功能

# 修复分支
hotfix/auth-bug           # 认证相关 bug 修复
hotfix/performance-issue  # 性能问题修复

# 分支命名规范
feature/功能名称
hotfix/问题描述
release/版本号
```

### 3. **代码审查流程**

#### 审查清单
```markdown
## 代码审查清单

### 功能完整性
- [ ] 功能需求是否完整实现
- [ ] 边界情况是否考虑
- [ ] 错误处理是否完善

### 代码质量
- [ ] 代码是否清晰易读
- [ ] 命名是否规范
- [ ] 注释是否充分

### 性能考虑
- [ ] 是否有性能瓶颈
- [ ] 数据库查询是否优化
- [ ] 缓存策略是否合理

### 安全考虑
- [ ] 输入验证是否充分
- [ ] 权限控制是否正确
- [ ] 敏感信息是否保护

### 测试覆盖
- [ ] 单元测试是否覆盖
- [ ] 集成测试是否通过
- [ ] 手动测试是否完成
```

## 🧪 测试指南

### 1. **后端测试**

#### 单元测试
```go
// internal/services/proxy_service_test.go
package services

import (
    "context"
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// Mock 数据库
type MockProxyRepository struct {
    mock.Mock
}

func (m *MockProxyRepository) Create(ctx context.Context, proxy *Proxy) error {
    args := m.Called(ctx, proxy)
    return args.Error(0)
}

// 测试用例
func TestProxyService_CreateProxy(t *testing.T) {
    // 准备测试数据
    mockRepo := new(MockProxyRepository)
    service := NewProxyService(mockRepo)
    
    req := CreateProxyRequest{
        Name:        "测试代理",
        TargetURL:   "https://example.com",
        ProxyDomain: "proxy.example.com",
    }
    
    // 设置 Mock 期望
    mockRepo.On("Create", mock.Anything, mock.AnythingOfType("*Proxy")).Return(nil)
    
    // 执行测试
    proxy, err := service.CreateProxy(context.Background(), req)
    
    // 验证结果
    assert.NoError(t, err)
    assert.NotNil(t, proxy)
    assert.Equal(t, req.Name, proxy.Name)
    assert.Equal(t, req.TargetURL, proxy.TargetURL)
    
    // 验证 Mock 调用
    mockRepo.AssertExpectations(t)
}
```

#### 集成测试
```go
// tests/integration/proxy_test.go
package integration

import (
    "testing"
    "net/http"
    "net/http/httptest"
    "encoding/json"
    "github.com/stretchr/testify/assert"
)

func TestProxyAPI_CreateProxy(t *testing.T) {
    // 启动测试服务器
    app := setupTestApp()
    defer app.Cleanup()
    
    // 创建测试请求
    reqBody := map[string]interface{}{
        "name":         "测试代理",
        "target_url":   "https://example.com",
        "proxy_domain": "proxy.example.com",
    }
    
    reqBodyBytes, _ := json.Marshal(reqBody)
    req := httptest.NewRequest("POST", "/api/proxy/configs", bytes.NewReader(reqBodyBytes))
    req.Header.Set("Content-Type", "application/json")
    
    // 执行请求
    w := httptest.NewRecorder()
    app.ServeHTTP(w, req)
    
    // 验证响应
    assert.Equal(t, http.StatusCreated, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    
    assert.True(t, response["success"].(bool))
    assert.NotNil(t, response["data"])
}
```

### 2. **前端测试**

#### 组件测试
```typescript
// tests/unit/ProxyManagement.spec.ts
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import ProxyManagement from '@/views/proxy/ProxyManagement.vue'
import { useProxyStore } from '@/store/proxy'

describe('ProxyManagement.vue', () => {
  let wrapper: any
  let store: any
  
  beforeEach(() => {
    setActivePinia(createPinia())
    store = useProxyStore()
    
    // Mock store 方法
    vi.spyOn(store, 'fetchConfigs').mockResolvedValue()
    
    wrapper = mount(ProxyManagement)
  })
  
  afterEach(() => {
    wrapper.unmount()
  })
  
  it('renders proxy management title', () => {
    expect(wrapper.find('h1').text()).toBe('代理管理')
  })
  
  it('loads proxy configs on mount', () => {
    expect(store.fetchConfigs).toHaveBeenCalled()
  })
  
  it('displays loading state', () => {
    store.loading = true
    wrapper.vm.$nextTick()
    
    expect(wrapper.find('.el-loading-mask').exists()).toBe(true)
  })
})
```

#### API 测试
```typescript
// tests/unit/api/proxy.spec.ts
import { proxyApi } from '@/api/proxy'
import { vi, describe, it, expect, beforeEach } from 'vitest'

// Mock fetch
global.fetch = vi.fn()

describe('proxyApi', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })
  
  it('fetches proxy configs successfully', async () => {
    const mockResponse = {
      success: true,
      data: [
        { id: '1', name: 'Test Proxy', targetUrl: 'https://example.com' }
      ]
    }
    
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse
    })
    
    const result = await proxyApi.getConfigs()
    
    expect(result).toEqual(mockResponse)
    expect(fetch).toHaveBeenCalledWith('/api/proxy/configs', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    })
  })
  
  it('handles API errors', async () => {
    fetch.mockRejectedValueOnce(new Error('Network error'))
    
    await expect(proxyApi.getConfigs()).rejects.toThrow('Network error')
  })
})
```

## 🐛 调试技巧

### 1. **后端调试**

#### 日志调试
```go
// 添加详细日志
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    logger := logrus.WithFields(logrus.Fields{
        "method": r.Method,
        "path":   r.URL.Path,
        "ip":     r.RemoteAddr,
    })
    
    // 记录请求体
    body, _ := io.ReadAll(r.Body)
    logger.WithField("request_body", string(body)).Debug("Received request")
    
    // 重新设置请求体
    r.Body = io.NopCloser(bytes.NewBuffer(body))
    
    // 业务逻辑...
}
```

#### 性能分析
```go
// 使用 pprof 进行性能分析
import (
    "net/http"
    _ "net/http/pprof"
)

func main() {
    // 启动 pprof 服务
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // 主服务...
}
```

### 2. **前端调试**

#### Vue DevTools
```bash
# 安装 Vue DevTools 浏览器扩展
# Chrome: https://chrome.google.com/webstore/detail/vuejs-devtools/
# Firefox: https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/
```

#### 调试技巧
```typescript
// 使用 console 调试
const loadProxyConfigs = async () => {
  console.log('开始加载代理配置')
  console.log('当前状态:', { loading: loading.value, configs: proxyList.value })
  
  try {
    const store = useProxyStore()
    const result = await store.fetchConfigs()
    console.log('加载结果:', result)
  } catch (error) {
    console.error('加载失败:', error)
  }
}

// 使用 debugger 断点
const handleEdit = (proxy: ProxyConfig) => {
  debugger // 浏览器会在这里暂停
  console.log('编辑代理:', proxy)
  // 编辑逻辑...
}
```

## ❓ 常见问题

### 1. **后端常见问题**

#### 数据库连接问题
```bash
# 问题：无法连接数据库
# 解决方案：
1. 检查 PostgreSQL 服务是否启动
2. 检查配置文件中的数据库连接信息
3. 检查防火墙设置
4. 检查数据库用户权限

# 命令检查
sudo systemctl status postgresql
psql -U postgres -h localhost -d proxy_platform
```

#### 端口占用问题
```bash
# 问题：端口 8080 被占用
# 解决方案：
1. 查找占用端口的进程
lsof -i :8080

2. 杀死进程
kill -9 <PID>

3. 或者修改配置文件中的端口
```

### 2. **前端常见问题**

#### 依赖安装问题
```bash
# 问题：npm install 失败
# 解决方案：
1. 清除 npm 缓存
npm cache clean --force

2. 删除 node_modules 和 package-lock.json
rm -rf node_modules package-lock.json

3. 重新安装
npm install
```

#### 构建问题
```bash
# 问题：npm run build 失败
# 解决方案：
1. 检查 TypeScript 类型错误
npm run type-check

2. 检查 ESLint 错误
npm run lint

3. 清理构建缓存
rm -rf dist
```

### 3. **开发环境问题**

#### 热重载不工作
```bash
# 问题：代码修改后页面不自动刷新
# 解决方案：
1. 检查 Vite 配置
2. 重启开发服务器
3. 检查文件监听权限
```

#### 跨域问题
```bash
# 问题：前端调用后端 API 出现跨域错误
# 解决方案：
1. 检查后端 CORS 配置
2. 确保前后端端口配置正确
3. 使用统一架构避免跨域
```

## 📚 学习资源

### 1. **Go 学习资源**
- [Go 官方文档](https://golang.org/doc/)
- [Go Web 编程](https://github.com/astaxie/build-web-application-with-golang)
- [Go 标准库文档](https://pkg.go.dev/std)

### 2. **Vue 3 学习资源**
- [Vue 3 官方文档](https://vuejs.org/)
- [Vue 3 组合式 API](https://vuejs.org/guide/extras/composition-api-faq.html)
- [Element Plus 组件库](https://element-plus.org/)

### 3. **项目相关资源**
- [gorilla/mux 路由库](https://github.com/gorilla/mux)
- [GORM 数据库 ORM](https://gorm.io/)
- [Pinia 状态管理](https://pinia.vuejs.org/)

## 🎯 总结

本开发指南涵盖了 Proxy Enhancer Ultra 项目的完整开发流程，包括：

1. **环境搭建**：详细的开发环境配置步骤
2. **代码规范**：Go 和 Vue 的代码编写规范
3. **开发流程**：标准的功能开发流程和代码管理
4. **测试指南**：单元测试和集成测试的实现
5. **调试技巧**：前后端的调试方法和工具
6. **常见问题**：开发过程中可能遇到的问题和解决方案

遵循这些指南，可以确保代码质量，提高开发效率，减少开发过程中的问题。同时，这些规范也有助于团队协作和代码维护。

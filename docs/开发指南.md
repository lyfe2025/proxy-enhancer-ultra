# Proxy Enhancer Ultra - å¼€å‘æŒ‡å—

## ğŸ“‹ ç›®å½•
1. [å¼€å‘ç¯å¢ƒæ­å»º](#å¼€å‘ç¯å¢ƒæ­å»º)
2. [ä»£ç è§„èŒƒ](#ä»£ç è§„èŒƒ)
3. [å¼€å‘æµç¨‹](#å¼€å‘æµç¨‹)
4. [æµ‹è¯•æŒ‡å—](#æµ‹è¯•æŒ‡å—)
5. [è°ƒè¯•æŠ€å·§](#è°ƒè¯•æŠ€å·§)
6. [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

## ğŸš€ å¼€å‘ç¯å¢ƒæ­å»º

### ç¯å¢ƒè¦æ±‚

#### 1. **Go ç¯å¢ƒ**
```bash
# æ£€æŸ¥ Go ç‰ˆæœ¬
go version

# è¦æ±‚ï¼šGo 1.21 æˆ–æ›´é«˜ç‰ˆæœ¬
# ä¸‹è½½åœ°å€ï¼šhttps://golang.org/dl/
```

#### 2. **Node.js ç¯å¢ƒ**
```bash
# æ£€æŸ¥ Node.js ç‰ˆæœ¬
node --version
npm --version

# è¦æ±‚ï¼šNode.js 18+ å’Œ npm 8+
# æ¨èä½¿ç”¨ nvm ç®¡ç† Node.js ç‰ˆæœ¬
```

#### 3. **æ•°æ®åº“ç¯å¢ƒ**
```bash
# PostgreSQL 12+
# æœ¬åœ°å®‰è£… PostgreSQL
brew install postgresql  # macOS
sudo apt-get install postgresql postgresql-contrib  # Ubuntu
```

#### 4. **å¼€å‘å·¥å…·**
```bash
# æ¨è IDE
- GoLand / VS Code (Go å¼€å‘)
- VS Code / WebStorm (å‰ç«¯å¼€å‘)
- DBeaver / pgAdmin (æ•°æ®åº“ç®¡ç†)
```

### ç¯å¢ƒé…ç½®æ­¥éª¤

#### 1. **å…‹éš†é¡¹ç›®**
```bash
git clone <repository-url>
cd proxy-enhancer-ultra

# æ£€æŸ¥é¡¹ç›®ç»“æ„
ls -la
```

#### 2. **åç«¯ç¯å¢ƒé…ç½®**
```bash
# å®‰è£… Go ä¾èµ–
go mod download

# å¤åˆ¶é…ç½®æ–‡ä»¶
cp config.yaml.example config.yaml

# ç¼–è¾‘é…ç½®æ–‡ä»¶
vim config.yaml
```

**é…ç½®æ–‡ä»¶ç¤ºä¾‹**ï¼š
```yaml
# config.yaml
server:
  host: "0.0.0.0"
  port: 8080

database:
  postgres:
    host: "localhost"
    port: 5432
    user: "postgres"
    password: "your-password"
    dbname: "proxy_platform"
    sslmode: "disable"

jwt:
  secret: "your-secret-key-here"
  expires_in: 24h
```

#### 3. **å‰ç«¯ç¯å¢ƒé…ç½®**
```bash
# è¿›å…¥å‰ç«¯ç›®å½•
cd web

# å®‰è£…ä¾èµ–
npm install

# æ£€æŸ¥ä¾èµ–å®‰è£…
npm list --depth=0
```

#### 4. **æ•°æ®åº“åˆå§‹åŒ–**
```sql
-- è¿æ¥åˆ° PostgreSQL
psql -U postgres -h localhost

-- åˆ›å»ºæ•°æ®åº“
CREATE DATABASE proxy_platform;

-- åˆ›å»ºç”¨æˆ·ï¼ˆå¯é€‰ï¼‰
CREATE USER proxy_user WITH PASSWORD 'proxy_password';
GRANT ALL PRIVILEGES ON DATABASE proxy_platform TO proxy_user;

-- é€€å‡º
\q
```

### å¼€å‘ç¯å¢ƒå¯åŠ¨

#### 1. **å¯åŠ¨åç«¯æœåŠ¡**
```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•
go run cmd/server/main.go

# æˆ–è€…æ„å»ºåè¿è¡Œ
go build -o bin/server cmd/server/main.go
./bin/server
```

#### 2. **å¯åŠ¨å‰ç«¯å¼€å‘æœåŠ¡å™¨**
```bash
# åœ¨ web ç›®å½•
cd web
npm run dev

# å‰ç«¯å°†åœ¨ http://localhost:5173 å¯åŠ¨
```

#### 3. **éªŒè¯ç¯å¢ƒ**
```bash
# æ£€æŸ¥åç«¯æœåŠ¡
curl http://localhost:8080/health

# æ£€æŸ¥å‰ç«¯æœåŠ¡
open http://localhost:5173
```

## ğŸ“ ä»£ç è§„èŒƒ

### Go ä»£ç è§„èŒƒ

#### 1. **æ–‡ä»¶ç»„ç»‡**
```go
// æ–‡ä»¶ç»“æ„ç¤ºä¾‹
package proxy

import (
    // æ ‡å‡†åº“
    "context"
    "net/http"
    
    // ç¬¬ä¸‰æ–¹åº“
    "github.com/gorilla/mux"
    "gorm.io/gorm"
    
    // å†…éƒ¨åŒ…
    "proxy-enhancer-ultra/internal/models"
    "proxy-enhancer-ultra/internal/services"
)

// ç±»å‹å®šä¹‰
type ProxyHandler struct {
    proxyService *services.ProxyService
    db          *gorm.DB
}

// æ„é€ å‡½æ•°
func NewProxyHandler(proxyService *services.ProxyService, db *gorm.DB) *ProxyHandler {
    return &ProxyHandler{
        proxyService: proxyService,
        db:          db,
    }
}

// æ–¹æ³•å®ç°
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    // å®ç°é€»è¾‘
}
```

#### 2. **å‘½åè§„èŒƒ**
```go
// åŒ…åï¼šå°å†™ï¼Œç®€çŸ­
package proxy

// ç±»å‹åï¼šé©¼å³°å‘½åï¼Œé¦–å­—æ¯å¤§å†™
type ProxyConfig struct {
    ID          string    `json:"id"`
    Name        string    `json:"name"`
    TargetURL   string    `json:"target_url"`
    IsActive    bool      `json:"is_active"`
    CreatedAt   time.Time `json:"created_at"`
}

// æ–¹æ³•åï¼šé©¼å³°å‘½åï¼Œé¦–å­—æ¯å¤§å†™
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request)
func (h *ProxyHandler) GetProxyByID(w http.ResponseWriter, r *http.Request)

// å˜é‡åï¼šé©¼å³°å‘½åï¼Œé¦–å­—æ¯å°å†™
var proxyConfig ProxyConfig
var isActive bool
```

#### 3. **é”™è¯¯å¤„ç†**
```go
// é”™è¯¯å¤„ç†æœ€ä½³å®è·µ
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    // 1. è§£æè¯·æ±‚
    var req CreateProxyRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        logrus.WithError(err).Error("Failed to decode request")
        http.Error(w, "Invalid request format", http.StatusBadRequest)
        return
    }
    
    // 2. éªŒè¯è¯·æ±‚
    if err := h.validateRequest(req); err != nil {
        logrus.WithError(err).Error("Request validation failed")
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // 3. ä¸šåŠ¡é€»è¾‘
    proxy, err := h.proxyService.CreateProxy(r.Context(), req)
    if err != nil {
        logrus.WithError(err).Error("Failed to create proxy")
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    // 4. è¿”å›å“åº”
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(proxy)
}
```

#### 4. **æ—¥å¿—è§„èŒƒ**
```go
// ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
import "github.com/sirupsen/logrus"

func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    logger := logrus.WithFields(logrus.Fields{
        "method": r.Method,
        "path":   r.URL.Path,
        "ip":     r.RemoteAddr,
    })
    
    logger.Info("Creating new proxy configuration")
    
    // ä¸šåŠ¡é€»è¾‘...
    
    if err != nil {
        logger.WithError(err).Error("Failed to create proxy")
        return
    }
    
    logger.WithField("proxy_id", proxy.ID).Info("Proxy created successfully")
}
```

### å‰ç«¯ä»£ç è§„èŒƒ

#### 1. **Vue ç»„ä»¶ç»“æ„**
```vue
<template>
  <!-- æ¨¡æ¿å†…å®¹ -->
  <div class="proxy-management">
    <el-card>
      <template #header>
        <span>ä»£ç†ç®¡ç†</span>
      </template>
      
      <el-table :data="proxyList" v-loading="loading">
        <!-- è¡¨æ ¼å†…å®¹ -->
      </el-table>
    </el-card>
  </div>
</template>

<script setup lang="ts">
// å¯¼å…¥
import { ref, onMounted } from 'vue'
import { useProxyStore } from '@/store/proxy'
import type { ProxyConfig } from '@/types'

// ç±»å‹å®šä¹‰
interface Props {
  title?: string
}

// Props å’Œ Emits
const props = withDefaults(defineProps<Props>(), {
  title: 'ä»£ç†ç®¡ç†'
})

// å“åº”å¼çŠ¶æ€
const proxyList = ref<ProxyConfig[]>([])
const loading = ref(false)

// è®¡ç®—å±æ€§
const activeProxies = computed(() => 
  proxyList.value.filter(p => p.isActive)
)

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  await loadProxyConfigs()
})

// æ–¹æ³•
const loadProxyConfigs = async () => {
  loading.value = true
  try {
    const store = useProxyStore()
    proxyList.value = await store.fetchConfigs()
  } catch (error) {
    console.error('Failed to load proxy configs:', error)
  } finally {
    loading.value = false
  }
}
</script>

<style scoped>
.proxy-management {
  padding: 20px;
}
</style>
```

#### 2. **TypeScript ç±»å‹å®šä¹‰**
```typescript
// types/index.ts
export interface ProxyConfig {
  id: string
  name: string
  targetUrl: string
  proxyDomain: string
  isActive: boolean
  createdAt: string
  updatedAt: string
}

export interface CreateProxyRequest {
  name: string
  targetUrl: string
  proxyDomain: string
}

export interface ApiResponse<T> {
  success: boolean
  data?: T
  message?: string
  error?: string
}

// API å‡½æ•°ç±»å‹
export type ApiFunction<T = any, R = any> = (params: T) => Promise<ApiResponse<R>>
```

#### 3. **çŠ¶æ€ç®¡ç†è§„èŒƒ**
```typescript
// store/proxy.ts
import { defineStore } from 'pinia'
import type { ProxyConfig, CreateProxyRequest } from '@/types'
import { proxyApi } from '@/api/proxy'

export const useProxyStore = defineStore('proxy', {
  state: () => ({
    configs: [] as ProxyConfig[],
    loading: false,
    error: null as string | null,
  }),
  
  getters: {
    activeConfigs: (state) => state.configs.filter(c => c.isActive),
    configById: (state) => (id: string) => state.configs.find(c => c.id === id),
  },
  
  actions: {
    async fetchConfigs() {
      this.loading = true
      this.error = null
      
      try {
        const response = await proxyApi.getConfigs()
        if (response.success && response.data) {
          this.configs = response.data
        }
      } catch (error) {
        this.error = error instanceof Error ? error.message : 'Unknown error'
        throw error
      } finally {
        this.loading = false
      }
    },
    
    async createConfig(request: CreateProxyRequest) {
      this.loading = true
      this.error = null
      
      try {
        const response = await proxyApi.createConfig(request)
        if (response.success && response.data) {
          this.configs.push(response.data)
        }
        return response.data
      } catch (error) {
        this.error = error instanceof Error ? error.message : 'Unknown error'
        throw error
      } finally {
        this.loading = false
      }
    },
  },
})
```

## ğŸ”„ å¼€å‘æµç¨‹

### 1. **åŠŸèƒ½å¼€å‘æµç¨‹**

#### éœ€æ±‚åˆ†æ
```bash
# 1. ç†è§£éœ€æ±‚
- é˜…è¯»äº§å“éœ€æ±‚æ–‡æ¡£
- åˆ†ææŠ€æœ¯å¯è¡Œæ€§
- ç¡®å®šå¼€å‘èŒƒå›´

# 2. æŠ€æœ¯è®¾è®¡
- è®¾è®¡æ•°æ®æ¨¡å‹
- è®¾è®¡ API æ¥å£
- è®¾è®¡å‰ç«¯ç»„ä»¶
```

#### å¼€å‘å®æ–½
```bash
# 1. åç«¯å¼€å‘
- åˆ›å»ºæ•°æ®æ¨¡å‹
- å®ç°ä¸šåŠ¡æœåŠ¡
- å®ç° HTTP å¤„ç†å™¨
- æ·»åŠ è·¯ç”±é…ç½®

# 2. å‰ç«¯å¼€å‘
- åˆ›å»º Vue ç»„ä»¶
- å®ç°çŠ¶æ€ç®¡ç†
- æ·»åŠ è·¯ç”±é…ç½®
- å®ç° API è°ƒç”¨
```

#### æµ‹è¯•éªŒè¯
```bash
# 1. å•å…ƒæµ‹è¯•
go test ./internal/services/...
npm run test:unit

# 2. é›†æˆæµ‹è¯•
go test -tags=integration ./...
npm run test:integration

# 3. ç«¯åˆ°ç«¯æµ‹è¯•
npm run test:e2e
```

### 2. **ä»£ç æäº¤è§„èŒƒ**

#### Git æäº¤ä¿¡æ¯æ ¼å¼
```bash
# æäº¤ä¿¡æ¯æ ¼å¼
<type>(<scope>): <subject>

# ç±»å‹è¯´æ˜
feat:     æ–°åŠŸèƒ½
fix:      ä¿®å¤ bug
docs:     æ–‡æ¡£æ›´æ–°
style:    ä»£ç æ ¼å¼è°ƒæ•´
refactor: ä»£ç é‡æ„
test:     æµ‹è¯•ç›¸å…³
chore:    æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨

# ç¤ºä¾‹
feat(proxy): æ·»åŠ ä»£ç†é…ç½®ç®¡ç†åŠŸèƒ½
fix(auth): ä¿®å¤ JWT è¿‡æœŸæ—¶é—´è®¡ç®—é”™è¯¯
docs(readme): æ›´æ–°é¡¹ç›®å¯åŠ¨è¯´æ˜
style(api): ç»Ÿä¸€ API å“åº”æ ¼å¼
```

#### åˆ†æ”¯ç®¡ç†ç­–ç•¥
```bash
# ä¸»åˆ†æ”¯
main        # ç”Ÿäº§ç¯å¢ƒåˆ†æ”¯
develop     # å¼€å‘ç¯å¢ƒåˆ†æ”¯

# åŠŸèƒ½åˆ†æ”¯
feature/proxy-management    # ä»£ç†ç®¡ç†åŠŸèƒ½
feature/rule-engine        # è§„åˆ™å¼•æ“åŠŸèƒ½
feature/user-management    # ç”¨æˆ·ç®¡ç†åŠŸèƒ½

# ä¿®å¤åˆ†æ”¯
hotfix/auth-bug           # è®¤è¯ç›¸å…³ bug ä¿®å¤
hotfix/performance-issue  # æ€§èƒ½é—®é¢˜ä¿®å¤

# åˆ†æ”¯å‘½åè§„èŒƒ
feature/åŠŸèƒ½åç§°
hotfix/é—®é¢˜æè¿°
release/ç‰ˆæœ¬å·
```

### 3. **ä»£ç å®¡æŸ¥æµç¨‹**

#### å®¡æŸ¥æ¸…å•
```markdown
## ä»£ç å®¡æŸ¥æ¸…å•

### åŠŸèƒ½å®Œæ•´æ€§
- [ ] åŠŸèƒ½éœ€æ±‚æ˜¯å¦å®Œæ•´å®ç°
- [ ] è¾¹ç•Œæƒ…å†µæ˜¯å¦è€ƒè™‘
- [ ] é”™è¯¯å¤„ç†æ˜¯å¦å®Œå–„

### ä»£ç è´¨é‡
- [ ] ä»£ç æ˜¯å¦æ¸…æ™°æ˜“è¯»
- [ ] å‘½åæ˜¯å¦è§„èŒƒ
- [ ] æ³¨é‡Šæ˜¯å¦å……åˆ†

### æ€§èƒ½è€ƒè™‘
- [ ] æ˜¯å¦æœ‰æ€§èƒ½ç“¶é¢ˆ
- [ ] æ•°æ®åº“æŸ¥è¯¢æ˜¯å¦ä¼˜åŒ–
- [ ] ç¼“å­˜ç­–ç•¥æ˜¯å¦åˆç†

### å®‰å…¨è€ƒè™‘
- [ ] è¾“å…¥éªŒè¯æ˜¯å¦å……åˆ†
- [ ] æƒé™æ§åˆ¶æ˜¯å¦æ­£ç¡®
- [ ] æ•æ„Ÿä¿¡æ¯æ˜¯å¦ä¿æŠ¤

### æµ‹è¯•è¦†ç›–
- [ ] å•å…ƒæµ‹è¯•æ˜¯å¦è¦†ç›–
- [ ] é›†æˆæµ‹è¯•æ˜¯å¦é€šè¿‡
- [ ] æ‰‹åŠ¨æµ‹è¯•æ˜¯å¦å®Œæˆ
```

## ğŸ§ª æµ‹è¯•æŒ‡å—

### 1. **åç«¯æµ‹è¯•**

#### å•å…ƒæµ‹è¯•
```go
// internal/services/proxy_service_test.go
package services

import (
    "context"
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// Mock æ•°æ®åº“
type MockProxyRepository struct {
    mock.Mock
}

func (m *MockProxyRepository) Create(ctx context.Context, proxy *Proxy) error {
    args := m.Called(ctx, proxy)
    return args.Error(0)
}

// æµ‹è¯•ç”¨ä¾‹
func TestProxyService_CreateProxy(t *testing.T) {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    mockRepo := new(MockProxyRepository)
    service := NewProxyService(mockRepo)
    
    req := CreateProxyRequest{
        Name:        "æµ‹è¯•ä»£ç†",
        TargetURL:   "https://example.com",
        ProxyDomain: "proxy.example.com",
    }
    
    // è®¾ç½® Mock æœŸæœ›
    mockRepo.On("Create", mock.Anything, mock.AnythingOfType("*Proxy")).Return(nil)
    
    // æ‰§è¡Œæµ‹è¯•
    proxy, err := service.CreateProxy(context.Background(), req)
    
    // éªŒè¯ç»“æœ
    assert.NoError(t, err)
    assert.NotNil(t, proxy)
    assert.Equal(t, req.Name, proxy.Name)
    assert.Equal(t, req.TargetURL, proxy.TargetURL)
    
    // éªŒè¯ Mock è°ƒç”¨
    mockRepo.AssertExpectations(t)
}
```

#### é›†æˆæµ‹è¯•
```go
// tests/integration/proxy_test.go
package integration

import (
    "testing"
    "net/http"
    "net/http/httptest"
    "encoding/json"
    "github.com/stretchr/testify/assert"
)

func TestProxyAPI_CreateProxy(t *testing.T) {
    // å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨
    app := setupTestApp()
    defer app.Cleanup()
    
    // åˆ›å»ºæµ‹è¯•è¯·æ±‚
    reqBody := map[string]interface{}{
        "name":         "æµ‹è¯•ä»£ç†",
        "target_url":   "https://example.com",
        "proxy_domain": "proxy.example.com",
    }
    
    reqBodyBytes, _ := json.Marshal(reqBody)
    req := httptest.NewRequest("POST", "/api/proxy/configs", bytes.NewReader(reqBodyBytes))
    req.Header.Set("Content-Type", "application/json")
    
    // æ‰§è¡Œè¯·æ±‚
    w := httptest.NewRecorder()
    app.ServeHTTP(w, req)
    
    // éªŒè¯å“åº”
    assert.Equal(t, http.StatusCreated, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    
    assert.True(t, response["success"].(bool))
    assert.NotNil(t, response["data"])
}
```

### 2. **å‰ç«¯æµ‹è¯•**

#### ç»„ä»¶æµ‹è¯•
```typescript
// tests/unit/ProxyManagement.spec.ts
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import ProxyManagement from '@/views/proxy/ProxyManagement.vue'
import { useProxyStore } from '@/store/proxy'

describe('ProxyManagement.vue', () => {
  let wrapper: any
  let store: any
  
  beforeEach(() => {
    setActivePinia(createPinia())
    store = useProxyStore()
    
    // Mock store æ–¹æ³•
    vi.spyOn(store, 'fetchConfigs').mockResolvedValue()
    
    wrapper = mount(ProxyManagement)
  })
  
  afterEach(() => {
    wrapper.unmount()
  })
  
  it('renders proxy management title', () => {
    expect(wrapper.find('h1').text()).toBe('ä»£ç†ç®¡ç†')
  })
  
  it('loads proxy configs on mount', () => {
    expect(store.fetchConfigs).toHaveBeenCalled()
  })
  
  it('displays loading state', () => {
    store.loading = true
    wrapper.vm.$nextTick()
    
    expect(wrapper.find('.el-loading-mask').exists()).toBe(true)
  })
})
```

#### API æµ‹è¯•
```typescript
// tests/unit/api/proxy.spec.ts
import { proxyApi } from '@/api/proxy'
import { vi, describe, it, expect, beforeEach } from 'vitest'

// Mock fetch
global.fetch = vi.fn()

describe('proxyApi', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })
  
  it('fetches proxy configs successfully', async () => {
    const mockResponse = {
      success: true,
      data: [
        { id: '1', name: 'Test Proxy', targetUrl: 'https://example.com' }
      ]
    }
    
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse
    })
    
    const result = await proxyApi.getConfigs()
    
    expect(result).toEqual(mockResponse)
    expect(fetch).toHaveBeenCalledWith('/api/proxy/configs', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    })
  })
  
  it('handles API errors', async () => {
    fetch.mockRejectedValueOnce(new Error('Network error'))
    
    await expect(proxyApi.getConfigs()).rejects.toThrow('Network error')
  })
})
```

## ğŸ› è°ƒè¯•æŠ€å·§

### 1. **åç«¯è°ƒè¯•**

#### æ—¥å¿—è°ƒè¯•
```go
// æ·»åŠ è¯¦ç»†æ—¥å¿—
func (h *ProxyHandler) CreateProxy(w http.ResponseWriter, r *http.Request) {
    logger := logrus.WithFields(logrus.Fields{
        "method": r.Method,
        "path":   r.URL.Path,
        "ip":     r.RemoteAddr,
    })
    
    // è®°å½•è¯·æ±‚ä½“
    body, _ := io.ReadAll(r.Body)
    logger.WithField("request_body", string(body)).Debug("Received request")
    
    // é‡æ–°è®¾ç½®è¯·æ±‚ä½“
    r.Body = io.NopCloser(bytes.NewBuffer(body))
    
    // ä¸šåŠ¡é€»è¾‘...
}
```

#### æ€§èƒ½åˆ†æ
```go
// ä½¿ç”¨ pprof è¿›è¡Œæ€§èƒ½åˆ†æ
import (
    "net/http"
    _ "net/http/pprof"
)

func main() {
    // å¯åŠ¨ pprof æœåŠ¡
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // ä¸»æœåŠ¡...
}
```

### 2. **å‰ç«¯è°ƒè¯•**

#### Vue DevTools
```bash
# å®‰è£… Vue DevTools æµè§ˆå™¨æ‰©å±•
# Chrome: https://chrome.google.com/webstore/detail/vuejs-devtools/
# Firefox: https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/
```

#### è°ƒè¯•æŠ€å·§
```typescript
// ä½¿ç”¨ console è°ƒè¯•
const loadProxyConfigs = async () => {
  console.log('å¼€å§‹åŠ è½½ä»£ç†é…ç½®')
  console.log('å½“å‰çŠ¶æ€:', { loading: loading.value, configs: proxyList.value })
  
  try {
    const store = useProxyStore()
    const result = await store.fetchConfigs()
    console.log('åŠ è½½ç»“æœ:', result)
  } catch (error) {
    console.error('åŠ è½½å¤±è´¥:', error)
  }
}

// ä½¿ç”¨ debugger æ–­ç‚¹
const handleEdit = (proxy: ProxyConfig) => {
  debugger // æµè§ˆå™¨ä¼šåœ¨è¿™é‡Œæš‚åœ
  console.log('ç¼–è¾‘ä»£ç†:', proxy)
  // ç¼–è¾‘é€»è¾‘...
}
```

## â“ å¸¸è§é—®é¢˜

### 1. **åç«¯å¸¸è§é—®é¢˜**

#### æ•°æ®åº“è¿æ¥é—®é¢˜
```bash
# é—®é¢˜ï¼šæ— æ³•è¿æ¥æ•°æ®åº“
# è§£å†³æ–¹æ¡ˆï¼š
1. æ£€æŸ¥ PostgreSQL æœåŠ¡æ˜¯å¦å¯åŠ¨
2. æ£€æŸ¥é…ç½®æ–‡ä»¶ä¸­çš„æ•°æ®åº“è¿æ¥ä¿¡æ¯
3. æ£€æŸ¥é˜²ç«å¢™è®¾ç½®
4. æ£€æŸ¥æ•°æ®åº“ç”¨æˆ·æƒé™

# å‘½ä»¤æ£€æŸ¥
sudo systemctl status postgresql
psql -U postgres -h localhost -d proxy_platform
```

#### ç«¯å£å ç”¨é—®é¢˜
```bash
# é—®é¢˜ï¼šç«¯å£ 8080 è¢«å ç”¨
# è§£å†³æ–¹æ¡ˆï¼š
1. æŸ¥æ‰¾å ç”¨ç«¯å£çš„è¿›ç¨‹
lsof -i :8080

2. æ€æ­»è¿›ç¨‹
kill -9 <PID>

3. æˆ–è€…ä¿®æ”¹é…ç½®æ–‡ä»¶ä¸­çš„ç«¯å£
```

### 2. **å‰ç«¯å¸¸è§é—®é¢˜**

#### ä¾èµ–å®‰è£…é—®é¢˜
```bash
# é—®é¢˜ï¼šnpm install å¤±è´¥
# è§£å†³æ–¹æ¡ˆï¼š
1. æ¸…é™¤ npm ç¼“å­˜
npm cache clean --force

2. åˆ é™¤ node_modules å’Œ package-lock.json
rm -rf node_modules package-lock.json

3. é‡æ–°å®‰è£…
npm install
```

#### æ„å»ºé—®é¢˜
```bash
# é—®é¢˜ï¼šnpm run build å¤±è´¥
# è§£å†³æ–¹æ¡ˆï¼š
1. æ£€æŸ¥ TypeScript ç±»å‹é”™è¯¯
npm run type-check

2. æ£€æŸ¥ ESLint é”™è¯¯
npm run lint

3. æ¸…ç†æ„å»ºç¼“å­˜
rm -rf dist
```

### 3. **å¼€å‘ç¯å¢ƒé—®é¢˜**

#### çƒ­é‡è½½ä¸å·¥ä½œ
```bash
# é—®é¢˜ï¼šä»£ç ä¿®æ”¹åé¡µé¢ä¸è‡ªåŠ¨åˆ·æ–°
# è§£å†³æ–¹æ¡ˆï¼š
1. æ£€æŸ¥ Vite é…ç½®
2. é‡å¯å¼€å‘æœåŠ¡å™¨
3. æ£€æŸ¥æ–‡ä»¶ç›‘å¬æƒé™
```

#### è·¨åŸŸé—®é¢˜
```bash
# é—®é¢˜ï¼šå‰ç«¯è°ƒç”¨åç«¯ API å‡ºç°è·¨åŸŸé”™è¯¯
# è§£å†³æ–¹æ¡ˆï¼š
1. æ£€æŸ¥åç«¯ CORS é…ç½®
2. ç¡®ä¿å‰åç«¯ç«¯å£é…ç½®æ­£ç¡®
3. ä½¿ç”¨ç»Ÿä¸€æ¶æ„é¿å…è·¨åŸŸ
```

## ğŸ“š å­¦ä¹ èµ„æº

### 1. **Go å­¦ä¹ èµ„æº**
- [Go å®˜æ–¹æ–‡æ¡£](https://golang.org/doc/)
- [Go Web ç¼–ç¨‹](https://github.com/astaxie/build-web-application-with-golang)
- [Go æ ‡å‡†åº“æ–‡æ¡£](https://pkg.go.dev/std)

### 2. **Vue 3 å­¦ä¹ èµ„æº**
- [Vue 3 å®˜æ–¹æ–‡æ¡£](https://vuejs.org/)
- [Vue 3 ç»„åˆå¼ API](https://vuejs.org/guide/extras/composition-api-faq.html)
- [Element Plus ç»„ä»¶åº“](https://element-plus.org/)

### 3. **é¡¹ç›®ç›¸å…³èµ„æº**
- [gorilla/mux è·¯ç”±åº“](https://github.com/gorilla/mux)
- [GORM æ•°æ®åº“ ORM](https://gorm.io/)
- [Pinia çŠ¶æ€ç®¡ç†](https://pinia.vuejs.org/)

## ğŸ¯ æ€»ç»“

æœ¬å¼€å‘æŒ‡å—æ¶µç›–äº† Proxy Enhancer Ultra é¡¹ç›®çš„å®Œæ•´å¼€å‘æµç¨‹ï¼ŒåŒ…æ‹¬ï¼š

1. **ç¯å¢ƒæ­å»º**ï¼šè¯¦ç»†çš„å¼€å‘ç¯å¢ƒé…ç½®æ­¥éª¤
2. **ä»£ç è§„èŒƒ**ï¼šGo å’Œ Vue çš„ä»£ç ç¼–å†™è§„èŒƒ
3. **å¼€å‘æµç¨‹**ï¼šæ ‡å‡†çš„åŠŸèƒ½å¼€å‘æµç¨‹å’Œä»£ç ç®¡ç†
4. **æµ‹è¯•æŒ‡å—**ï¼šå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•çš„å®ç°
5. **è°ƒè¯•æŠ€å·§**ï¼šå‰åç«¯çš„è°ƒè¯•æ–¹æ³•å’Œå·¥å…·
6. **å¸¸è§é—®é¢˜**ï¼šå¼€å‘è¿‡ç¨‹ä¸­å¯èƒ½é‡åˆ°çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

éµå¾ªè¿™äº›æŒ‡å—ï¼Œå¯ä»¥ç¡®ä¿ä»£ç è´¨é‡ï¼Œæé«˜å¼€å‘æ•ˆç‡ï¼Œå‡å°‘å¼€å‘è¿‡ç¨‹ä¸­çš„é—®é¢˜ã€‚åŒæ—¶ï¼Œè¿™äº›è§„èŒƒä¹Ÿæœ‰åŠ©äºå›¢é˜Ÿåä½œå’Œä»£ç ç»´æŠ¤ã€‚
